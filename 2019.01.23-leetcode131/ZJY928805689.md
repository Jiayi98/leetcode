### Note:
这道题的关键在于，类似于滑动窗口[start, end),iterate每一个start，对于固定的start，end向后移动

#### dfs:

  1. [0,1) -> [1,2) ->[2,3)->[3 return
  2. --------[1,3)->[3 reutrn 
  3. [0,2) -> [2,3)->[3 return 
  4. [0,3) -> [3 return

"""

    public class Solution {
    /*
     * @param s: A string
     * @return: A list of lists of string
     */
    public List<List<String>> partition(String s) {
        // write your code here
        List<List<String>> result = new ArrayList<>();
        if(s == null || s.length() == 0){
            return result;
        }
        
        //dfs(s, result, new ArrayList<>(), 0);
        dfs(s, result, new ArrayList<>(), 0, 1);
        return result;
    }
    private void dfs(String s, List<List<String>> result, List<String> partition, int start, int end){
        
        if(start == s.length()){

            result.add(new ArrayList<>(partition));
            return;
        }

        for(int i = end; i <= s.length(); i++){ // 这里是 <= 因为end是开区间excluded
            String sub = s.substring(start,i); // [start,end)
            System.out.println(start + " " + (start+i) + " " + sub);
            if(!isPalindrome(sub)){
                continue;
            }
            partition.add(sub);
            dfs(s,result, partition, i, i + 1);// [end, end+1)
            partition.remove(partition.size() - 1);
        }
    }
    
"""
